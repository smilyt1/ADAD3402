using UnityEngine;
using Unicessing;
public class ColorChartForUnicessing : UGraphics
{
    [SerializeField]
    private GameObject handLeft;
    [SerializeField]
    private GameObject handRight;

    private const int ChartWidth = 5; // Number of rows
    private const int ChartOffset = -300; // Width of the shape
    private const float ChartScale = 0.001f; // Size & Scale of the shape
    private const float ColorDelta = 0.005f; // Color of the outlines
    private const int PosDelta = 32; // Gaps between the rows

    private Vector3 handLeftPos, handRightPos;
    private Quaternion handLeftRot, handRightRot;

    protected override void Setup()
    {
        rotateDegrees();
        //stroke(100, 200, 255);
    }

    protected override void Draw()
    {
        UpdateHands();
        DrawHands();
        DrawColorChart();
    }

    void UpdateHands()
    {
        if ((handLeft == null) || (handRight == null))
        {
            Debug.LogError("Please set hand objects to hand fields on the inspector.");
        }
        else
        {
            handLeftPos = handLeft.transform.position;
            handRightPos = handRight.transform.position;
            handLeftRot = handLeft.transform.rotation;
            handRightRot = handRight.transform.rotation;
        }
    }

    void DrawHands()
    {
        DrawHandBox(handLeftPos, handLeftRot);
        DrawHandBox(handRightPos, handRightRot);
    }

    void DrawHandBox(Vector3 pos, Quaternion quat)
    {
        pushMatrix();
        translate(pos);
        rotate(quat.eulerAngles);
        noFill();
        box(1);
        popMatrix();
    }

    void DrawColorChart()
    {
        pushMatrix();
        for (float x = 0; x <= ChartWidth; x++)
        {
            for (float y = 0; y <= ChartWidth; y++)
            {
                for (float z = 0; z <= ChartWidth; z++)
                {
                    rotate(handLeftPos.z * 1f, handLeftPos.x * 1f, handLeftPos.y * 1f);
                    pushMatrix();
                    Color col = new Color(ColorDelta, ColorDelta, ColorDelta);
                    stroke(col);
                    fill(col);
                    float posX = (x * PosDelta + ChartOffset) * Random.Range(ChartScale, ChartScale + 0.001f);
                    float posY = (y * PosDelta + ChartOffset) * Random.Range(ChartScale, ChartScale + 0.001f) + handRightPos.y / 3;
                    float posZ = (z * PosDelta + ChartOffset) * Random.Range(ChartScale, ChartScale + 0.001f);
                    translate(posX, posY, posZ); // Displaces rows
                    translate(0.5f, 0.5f, 0.5f); // Displaces rows
                    rotate(handRightRot.eulerAngles);
                    box(0.1f); // Size of the Cubes
                    popMatrix();
                }
            }
        }
        popMatrix();
    }
}
